<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>CycleTime</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* ---------- FONTS ---------- */
    @font-face { font-family: 'SonsCondensed'; src: url('fonts/SonsCondensed-Semibold.ttf') format('truetype'); font-weight: 600; }
    @font-face { font-family: 'SonsCondensedExtra'; src: url('fonts/SonsCondensed-Extrabold.ttf') format('truetype'); font-weight: 800; }
    @font-face { font-family: 'Inter'; src: url('fonts/Inter-Regular.otf') format('opentype'); font-weight: 400; }

    :root{
      --green: #c8ff08;
      --teal:  #005E60;
      --btn-hover: #a6d607;
      --teal-dark: #013d3d;
    }

    html,body{height:100%; margin:0;}
    body{
      background:var(--teal);
      color:white;
      font-family: 'SonsCondensed', Arial, sans-serif;
      display:flex;
      flex-direction:column;
      min-height:100vh;
    }

    #banner{
      width:100%;
      height:15vh;
      max-height:180px;
      object-fit:contain;
      background:var(--teal);
      display:block;
    }

    /* Pale + Moule + Type top-left */
    #paleStat, #mouleStat, #typeStat {
      position: absolute;
      left: 20px;
      font-size: 6vh;
      font-family: 'SonsCondensed', sans-serif;
    }
    #paleStat { top: 40px; display:flex; align-items:center; gap:0.6ch; }
    #mouleStat { top: 100px; }
    #typeStat { top: 160px; text-decoration:none; cursor:default; }

    /* small inline pale input placed inside #paleStat - now sober and matching design */
    #paleInlineInput {
      display: none; /* visible only while running */
      margin-left: 0.1ch;
      font-family: 'SonsCondensed', sans-serif;
      font-size: 6vh;          /* same as stats */
      font-weight: 600;        /* matches .value */
      color: white;            /* same as stats text */
      background: transparent; /* no box */
      border: none;
      outline: none;
      cursor: not-allowed;
      pointer-events: none;    /* not clickable */
    }

    /* Ensure placeholder is subtle */
    #paleInlineInput::placeholder { color: rgba(255,255,255,0.35); }

    /* Stats top-right */
    #stats {
      position: absolute;
      top: 40px;
      right: 20px;
      font-size: 6vh;
      font-family: 'SonsCondensed', sans-serif;
      display: grid;
      gap: 6px 18px;
    }
    .stat { display:flex; justify-content:flex-end; gap:12px; }
    .label { min-width:10ch; text-align:right; font-weight:600; }
    .value { min-width:12ch; text-align:left; font-weight:600; }
    .target-time { color: var(--green); }

    /* Timer */
    #main { flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center; }
    #timer {
      font-family: 'SonsCondensedExtra','Courier New',monospace;
      font-variant-numeric: tabular-nums;
      font-size: 50vh;
      min-width:7.05ch;
      text-align:left;
      line-height:1;
      margin:0 auto 2vh auto;
      color: var(--green);
      transition: color .2s ease;
    }
    #timer.red {
      color:red;
      -webkit-text-stroke: 4px var(--teal-dark);
      text-shadow:
        -1px -1px 0 var(--teal-dark),
         1px -1px 0 var(--teal-dark),
        -1px  1px 0 var(--teal-dark),
         1px  1px 0 var(--teal-dark);
    }

    /* Blade input + Start */
    #bladeContainer{ display:flex; gap:1vw; align-items:center; justify-content:center; margin-top:1vh; }
    #bladeInput {
      font-family:'Inter',sans-serif;
      font-size:2.3vh;
      height:5.5vh; min-height:40px;
      border-radius:0.1vh;
      border:none;
      padding:0 1.6vh;
      width:12ch;
      text-align:center;
      background:#fff;
      color:var(--teal);
    }

    button.controlBtn {
      font-family:'Inter',sans-serif;
      font-size:2.3vh;
      height:6.5vh; min-height:40px;
      border-radius:1vh;
      border:none;
      padding:0 1.6vh;
      background:white;
      color:var(--teal);
      cursor:pointer;
    }

    button.controlBtn[disabled]{ opacity:1; cursor:not-allowed; background:#888; color:#ddd; }
    button.controlBtn:hover:not([disabled]){ background:var(--green); color:#003; }
    #stopBtn{ display:none; margin-top:1.5vh; }

    /* Fullscreen button (square) */
    #fullscreenBtn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width:44px;
      height:44px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0);
      border: none;
      border-radius: 8px;
      padding: 6px;
      cursor: pointer;
      z-index: 9999;
    }
    #fullscreenBtn:hover { background: rgba(255,255,255,0.12); }
    #fullscreenBtn img { width: 28px; height: 28px; display:block; }

    /* Settings button */
    #settingsBtn {
      position: fixed;
      top: 20px;
      right: 20px;
      width:56px;
      height:56px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,0);
      border: none;
      border-radius: 8px;
      padding: 6px;
      cursor: pointer;
      z-index: 9999;
    }
    #settingsBtn:hover { background: rgba(255,255,255,0.12); }
    #settingsBtn img { width: 40px; height: 40px; display:block; }

    /* Popup (password) */
    #popupOverlay{ position:fixed; inset:0; display:none; justify-content:center; align-items:center; background:rgba(0,0,0,0.55); z-index:60; }
    #popup{
      background:#fff;
      padding:22px 28px;
      border-radius:12px;
      min-width:300px;
      text-align:center;
      font-family:'Inter',sans-serif;
      box-shadow:0 8px 30px rgba(0,0,0,0.35);
    }
    #popup h2{ margin:0 0 12px; font-size:1.2rem; color:#000; }
    #popup input{
      width:86%;
      padding:8px;
      text-align:center;
      font-size:1rem;
      border:1px solid #ccc;
      border-radius:6px;
    }
    #popup .buttons{ margin-top:12px; display:flex; justify-content:center; gap:12px; }
    #popup .buttons button{ font-family:'Inter',sans-serif; font-size:1rem; padding:8px 14px; border:none; border-radius:8px; cursor:pointer; }
    #popup .msg{ margin-top:8px; color:#b00; min-height:1.1em; }

    /* Settings modal (Inter font) */
    #settingsOverlay{ position:fixed; inset:0; display:none; justify-content:center; align-items:center; background:rgba(0,0,0,0.55); z-index:70; }
    #settings {
      background:#fff; color:#000; padding:22px; border-radius:10px; min-width:360px; box-shadow:0 6px 18px rgba(0,0,0,0.35);
      font-family:'Inter',sans-serif;
    }
    #settings h3{ margin-top:0; margin-bottom:8px; font-size:1.2rem; }
    .settings-row{ display:flex; gap:12px; align-items:center; margin:8px 0; }
    .settings-row label{ width:110px; font-weight:600; font-size:0.95rem; }
    .settings-row input[type="text"], .settings-row input[type="number"], #typeInput {
      padding:10px; border-radius:6px; border:1px solid #ccc; width:155px; font-size:1rem;
      font-family: 'Inter', sans-serif;
    }
    .time-parts { display:inline-flex; gap:6px; align-items:center; }

    /* Make time inputs use Inter explicitly (requested) and ensure style consistent */
    .time-parts input {
      width:30px;
      text-align:center;
      padding:8px;
      border-radius:6px;
      border:1px solid #ccc;
      font-size:1rem;
      font-family: 'Inter', sans-serif;
      background:white;
      color:#003;
    }

    /* muted (grayed) look for current time when not edited */
    .muted {
      opacity: 0.45;
    }

    #settings .btns{ display:flex; gap:12px; justify-content:flex-end; margin-top:14px; }
    #settings .btns button{ padding:10px 16px; border-radius:8px; border:none; cursor:pointer; font-size:1rem; }

    /* Cursor normalization */
    #paleStat, #mouleStat, #typeStat,
    #stats, #stats .stat, #stats .label, #stats .value,
    #paleInlineInput {
      cursor: default;
    }
    button,
    #fullscreenBtn,
    #settingsBtn {
      cursor: pointer;
    }
    button[disabled] {
      cursor: not-allowed;
    }
    #bladeInput,
    #paleInput,
    #typeInput,
    #mouleInput,
    #targetHours,
    #targetMinutes,
    #targetSeconds {
      cursor: text;
    }

    @media (max-width:600px){
      #settings{ min-width:90%; }
      .settings-row label{ width:80px; }
      .time-parts input { width:44px; }
    }
  </style>
</head>
<body>
  <img id="banner" src="images/gebanner3.jpg" alt="GE banner">
  <div id="paleStat">Pale : <input id="paleInlineInput" type="text" maxlength="8" inputmode="numeric" placeholder="1234" aria-label="Pale number"></div>
  <div id="mouleStat">Moule : 02</div>
  <div id="typeStat">Type : <span id="typeVal">47.3</span></div>

  <div id="stats">
    <div class="stat"><span class="label">Moyenne :</span><span class="value" id="averageVal">--:--:--</span></div>
    <div class="stat"><span class="label">Meilleur :</span><span class="value" id="bestVal">--:--:--</span></div>
    <div class="stat"><span class="label">Objectif :</span><span class="value target-time" id="targetVal">24:00:00</span></div>
  </div>

  <div id="main">
    <div id="timer">00:00:00</div>

    <div id="bladeContainer">
      <input id="bladeInput" type="text" maxlength="4" placeholder="Entrer # Pale Ici" inputmode="numeric" pattern="\d*">
      <button id="startBtn" class="controlBtn" disabled>Commencer</button>
    </div>

    <button id="stopBtn" class="controlBtn">Stop</button>

    <button id="fullscreenBtn" title="Plein écran">
      <img src="images/fullscreen.png" alt="Fullscreen" id="fullscreenIcon">
    </button>

    <button id="settingsBtn" title="Paramètres">
      <img src="images/settings.png" alt="Settings">
    </button>

  </div>

  <!-- password popup -->
  <div id="popupOverlay">
    <div id="popup" role="dialog" aria-modal="true">
      <h2>Veuillez entrer le mot de passe</h2>
      <input id="passwordInput" type="password" autocomplete="off" inputmode="text" />
      <div class="buttons">
        <button id="cancelPassword">Annuler</button>
        <button id="confirmPassword" disabled>Confirmer</button>
      </div>
      <div class="msg" id="popupMsg"></div>
    </div>
  </div>

  <!-- settings overlay -->
  <div id="settingsOverlay">
    <div id="settings" role="dialog" aria-modal="true">
      <h3>Paramètres</h3>

      <!-- Pale No row (hidden by default, shown only if timer is running) -->
      <div class="settings-row" id="paleRow" style="display:none;">
        <label for="paleInput">Pale No</label>
        <input id="paleInput" type="text" maxlength="4" inputmode="numeric" placeholder="1234">
      </div>

      <div class="settings-row">
        <label for="typeInput">Type</label>
        <input id="typeInput" type="text" maxlength="16" placeholder="ex: 47.3">
      </div>

      <div class="settings-row">
        <label for="mouleInput">Moule</label>
        <input id="mouleInput" type="text" maxlength="8" inputmode="text" placeholder="02">
      </div>

      <div class="settings-row">
        <label>Objectif</label>
        <div class="time-parts">
          <input id="targetHours" maxlength="3" inputmode="numeric" placeholder="24" title="Heures">
          <span>:</span>
          <input id="targetMinutes" maxlength="2" inputmode="numeric" placeholder="00" title="Minutes">
          <span>:</span>
          <input id="targetSeconds" maxlength="2" inputmode="numeric" placeholder="00" title="Secondes">
        </div>
      </div>

      <div class="settings-row">
        <label>Temps actuel</label>
        <div class="time-parts">
          <input id="currentHours" maxlength="3" inputmode="numeric" title="Heures">
          <span>:</span>
          <input id="currentMinutes" maxlength="2" inputmode="numeric" title="Minutes">
          <span>:</span>
          <input id="currentSeconds" maxlength="2" inputmode="numeric" title="Secondes">
        </div>
      </div>

      <div class="btns">
        <button id="closeSettings">Annuler</button>
        <button id="saveSettings" style="background:var(--green); color:#003">Sauvegarder</button>
      </div>
    </div>
  </div>

  <!-- audio element; play once when triggered -->
  <audio id="alarmSound" src="music/mario.mp3" preload="auto"></audio>

  <script>
    /* ====== CONFIG & STORAGE KEYS ====== */
    const PASSWORD = "4321";
    const LOCKOUT_SECONDS = 60;
    const STORAGE_KEY_CONFIG = 'ct_config_v2';
    const STORAGE_KEY_STATS = 'ct_stats_v2';

    /* ====== Defaults ====== */
    const DEFAULT_CONFIG = { type: "47.3", moule: "02", pale: "", targetSec: 24 * 3600 };

    /* ====== STATE ====== */
    let config = loadConfigFromStorage();  // { type, moule, pale, targetSec }
    let stats = loadStatsFromStorage();    // keyed by type string
    let running = false;
    let startTimestamp = null;
    let tickTimeoutId = null;
    let alarmPlayed = false;
    let failCount = 0;
    let lockoutUntil = 0;
    let unlockContext = null; // "stop" or "settings"

    /* ====== ELEMENTS ====== */
    const timerEl = document.getElementById('timer');
    const typeValEl = document.getElementById('typeVal');
    const mouleStatEl = document.getElementById('mouleStat');
    const targetValEl = document.getElementById('targetVal');
    const averageVal = document.getElementById('averageVal');
    const bestVal = document.getElementById('bestVal');
    const paleStat = document.getElementById('paleStat');
    const paleInlineInput = document.getElementById('paleInlineInput');
    const bladeInput = document.getElementById('bladeInput');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const popupOverlay = document.getElementById('popupOverlay');
    const passwordInput = document.getElementById('passwordInput');
    const confirmPassword = document.getElementById('confirmPassword');
    const cancelPassword = document.getElementById('cancelPassword');
    const popupMsg = document.getElementById('popupMsg');
    const alarmSound = document.getElementById('alarmSound');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const fullscreenIcon = document.getElementById('fullscreenIcon');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsOverlay = document.getElementById('settingsOverlay');
    const typeInput = document.getElementById('typeInput');
    const paleInput = document.getElementById('paleInput');
    const mouleInput = document.getElementById('mouleInput');
    const targetHours = document.getElementById('targetHours');
    const targetMinutes = document.getElementById('targetMinutes');
    const targetSeconds = document.getElementById('targetSeconds');
    const saveSettings = document.getElementById('saveSettings');
    const closeSettings = document.getElementById('closeSettings');
    const currentHours = document.getElementById('currentHours');
    const currentMinutes = document.getElementById('currentMinutes');
    const currentSeconds = document.getElementById('currentSeconds');

    /* ====== STORAGE helpers ====== */
    function loadConfigFromStorage(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY_CONFIG);
        if (!raw) {
          localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(DEFAULT_CONFIG));
          return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
        }
        const parsed = JSON.parse(raw);
        parsed.type = parsed.type || DEFAULT_CONFIG.type;
        parsed.moule = parsed.moule || DEFAULT_CONFIG.moule;
        parsed.pale = parsed.pale || DEFAULT_CONFIG.pale;
        parsed.targetSec = (typeof parsed.targetSec === 'number') ? parsed.targetSec : DEFAULT_CONFIG.targetSec;
        return parsed;
      } catch {
        localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(DEFAULT_CONFIG));
        return JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      }
    }
    function saveConfigToStorage(){
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(config));
    }

    function loadStatsFromStorage(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY_STATS);
        if (!raw){
          const base = {};
          localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(base));
          return base;
        }
        return JSON.parse(raw);
      } catch {
        const base = {};
        localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(base));
        return base;
      }
    }
    function saveStatsToStorage(){
      localStorage.setItem(STORAGE_KEY_STATS, JSON.stringify(stats));
    }

    /* ====== Time parsing/formatting ====== */
    function parseHMSParts(h,m,s){
      const hh = parseInt(h||'0',10) || 0;
      const mm = parseInt(m||'0',10) || 0;
      const ss = parseInt(s||'0',10) || 0;
      const minutes = Math.max(0, Math.min(59, mm));
      const seconds = Math.max(0, Math.min(59, ss));
      const hours = Math.max(0, hh);
      return hours * 3600 + minutes * 60 + seconds;
    }
    function secondsToHMS(sec){
      const h = Math.floor(sec/3600);
      const m = Math.floor((sec%3600)/60);
      const s = sec%60;
      return { h, m, s };
    }
    function formatHMS(s){
      const h = String(Math.floor(s/3600)).padStart(2,'0');
      const m = String(Math.floor((s%3600)/60)).padStart(2,'0');
      const sec = String(s%60).padStart(2,'0');
      return `${h}:${m}:${sec}`;
    }

    /* ====== UI helpers ====== */
    function ensureStatsEntryFor(type){
      if (!stats[type]) stats[type] = { runs: [], count: 0 };
    }

    function updateStatsUI(){
      const t = config.type;
      ensureStatsEntryFor(t);
      const runs = stats[t].runs || [];
      if (runs.length === 0){
        averageVal.textContent = '--:--:--';
        bestVal.textContent = '--:--:--';
      } else {
	const lastFive = runs.slice(-5);
        const avg = Math.floor(lastFive.reduce((a,b)=>a+b,0) / lastFive.length);
        const best = Math.min(...runs);
        averageVal.textContent = formatHMS(avg);
        bestVal.textContent = formatHMS(best);
      }
      targetValEl.textContent = formatHMS(config.targetSec || 0);
      typeValEl.textContent = config.type;
      mouleStatEl.textContent = 'Moule : ' + (config.moule || '');
      if (paleInlineInput.style.display !== 'none') {
        paleInlineInput.value = config.pale || '';
      } else {
        paleStat.title = config.pale || '';
      }
    }

    /* ====== Timer core (precise tick) ====== */
    function startTimer(){
      running = true;
      alarmPlayed = false;
      startTimestamp = Date.now();
      timerEl.textContent = '00:00:00';
      timerEl.classList.remove('red');
      scheduleTick();
      try { alarmSound.loop = false; } catch(e){}
      showPaleInline(true);
    }

    function scheduleTick(){
      if (!running) return;
      tick();
      const msSinceStart = Date.now() - startTimestamp;
      const nextTick = 1000 - (msSinceStart % 1000) || 1000;
      tickTimeoutId = setTimeout(scheduleTick, nextTick);
    }

    function tick(){
      if (!running) return;
      const elapsed = Math.floor((Date.now() - startTimestamp) / 1000);
      timerEl.textContent = formatHMS(elapsed);
      if (elapsed >= (config.targetSec || 0)){
        timerEl.classList.add('red');
        if (!alarmPlayed){
          alarmPlayed = true;
          try {
            alarmSound.currentTime = 0;
            alarmSound.play().catch(()=>{});
          } catch(e){}
        }
      } else {
        timerEl.classList.remove('red');
      }
    }

function stopTimerInternal(){
  if (tickTimeoutId){ clearTimeout(tickTimeoutId); tickTimeoutId = null; }
  running = false;
  alarmPlayed = false;
  try { alarmSound.pause(); alarmSound.currentTime = 0; } catch(e){}
  showPaleInline(false);

  // Reset display to 00:00:00 when stopped
  timerEl.textContent = '00:00:00';
  timerEl.classList.remove('red');
}

    /* ====== Inline pale input show/hide ====== */
    function showPaleInline(on) {
      if (on) {
        paleInlineInput.style.display = 'inline-block';
        paleInlineInput.value = config.pale || '';
      } else {
        paleInlineInput.style.display = 'none';
      }
    }

    /* ====== Input restrictions ====== */
    function onlyDigitsListener(el, maxLen){
      if (!el) return;
      el.addEventListener('input', ()=> {
        const cleaned = el.value.replace(/\D/g, '');
        el.value = (maxLen ? cleaned.slice(0,maxLen) : cleaned);
      });
      el.addEventListener('keydown', (e) => {
        const allowed = ['Backspace','Delete','ArrowLeft','ArrowRight','Tab','Home','End'];
        if (!allowed.includes(e.key) && !/^\d$/.test(e.key)) {
          e.preventDefault();
        }
      });
    }
    function digitsDotListener(el, maxLen){
      if (!el) return;
      el.addEventListener('input', ()=> {
        let cleaned = el.value.replace(/[^0-9.]/g, "");
        const parts = cleaned.split(".");
        if (parts.length > 2){
          cleaned = parts[0] + "." + parts.slice(1).join("");
        }
        el.value = (maxLen ? cleaned.slice(0,maxLen) : cleaned);
      });
      el.addEventListener('keydown', (e) => {
        const allowed = ['Backspace','Delete','ArrowLeft','ArrowRight','Tab','Home','End','.'];
        if (!allowed.includes(e.key) && !/^[0-9]$/.test(e.key)) {
          e.preventDefault();
        }
        if (e.key === "." && el.value.includes(".")) e.preventDefault();
      });
    }

    // Apply restrictions:
    onlyDigitsListener(bladeInput, 4);       // start input
    onlyDigitsListener(paleInput, 8);        // settings pale
    onlyDigitsListener(paleInlineInput, 8);  // inline pale while running
    digitsDotListener(typeInput, 16);        // type (e.g. 47.3)
    digitsDotListener(mouleInput, 8);        // moule (accept periods)
    onlyDigitsListener(targetHours, 3);
    onlyDigitsListener(targetMinutes, 2);
    onlyDigitsListener(targetSeconds, 2);
    onlyDigitsListener(currentHours, 3);
    onlyDigitsListener(currentMinutes, 2);
    onlyDigitsListener(currentSeconds, 2);

    /* ====== Start / Stop wiring ====== */
    bladeInput.addEventListener('input', () => {
      startBtn.disabled = bladeInput.value.replace(/\D/g,'').length !== 4;
    });

    startBtn.addEventListener('click', ()=> {
  if (bladeInput.value && bladeInput.value.length > 0){
    config.pale = bladeInput.value.replace(/\D/g,'');
    saveConfigToStorage();
  }

  paleInlineInput.value = config.pale || '';
  bladeInput.value = '';
  startBtn.disabled = true;
  document.getElementById('bladeContainer').style.display = 'none';
  stopBtn.style.display = 'inline-block';
  document.getElementById('paleRow').style.display = 'flex';

  // Determine if we have a pre-set elapsed time
  let elapsed = parseHMSParts(currentHours.value, currentMinutes.value, currentSeconds.value);

  // If elapsed is 0, start from zero
  if (!elapsed || elapsed <= 0) elapsed = 0;

  // Start timer with this elapsed
  running = true;
  alarmPlayed = false;
  startTimestamp = Date.now() - (elapsed * 1000);
  scheduleTick();
  updateStatsUI();
});

    stopBtn.addEventListener('click', ()=> {
      if (Date.now() < lockoutUntil){
        const remaining = Math.ceil((lockoutUntil - Date.now())/1000);
        alert(`Verrouillé. Attendez ${remaining}s.`);
        return;
      }
      unlockContext = "stop";
      popupOverlay.style.display = 'flex';
      passwordInput.value = '';
      confirmPassword.disabled = true;
      popupMsg.textContent = '';
      passwordInput.focus();
    });

    /* ====== Password popup logic (shared for Stop & Settings) ====== */
    passwordInput.addEventListener('input', ()=> {
      confirmPassword.disabled = passwordInput.value.trim().length === 0;
    });
    cancelPassword.addEventListener('click', ()=> {
      popupOverlay.style.display = 'none';
      passwordInput.value = '';
      confirmPassword.disabled = true;
      unlockContext = null;
    });
// === allow Enter to confirm while editing inputs in the settings modal ===
settingsOverlay.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    // only when settings modal is visible
    if (settingsOverlay.style.display !== 'flex') return;
    const active = document.activeElement;
    // only trigger if focus is inside an input/textarea
    if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) {
      e.preventDefault();
      saveSettings.click(); // simulate Save click
    }
  }
});

// === allow Enter to confirm password in popup ===
popupOverlay.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    // only when popup is visible
    if (popupOverlay.style.display !== 'flex') return;
    const active = document.activeElement;
    if (active && active.tagName === 'INPUT') {
      e.preventDefault();
      confirmPassword.click(); // simulate Confirm
    }
  }
});

    confirmPassword.addEventListener('click', ()=> {
      if (passwordInput.value === PASSWORD){
        popupOverlay.style.display = 'none';
        failCount = 0;

        if (unlockContext === "stop") {
          const elapsed = running && startTimestamp ? Math.floor((Date.now() - startTimestamp)/1000) : 0;
          stopTimerInternal();
          if (elapsed > 0){
            const t = config.type;
            ensureStatsEntryFor(t);
            stats[t].runs.push(elapsed);
            stats[t].count = (stats[t].count || 0) + 1;
            saveStatsToStorage();
          }
          updateStatsUI();
          timerEl.textContent = '00:00:00';
          timerEl.classList.remove('red');
          paleStat.setAttribute('data-value', '');
          document.getElementById('bladeContainer').style.display = 'flex';
          startBtn.disabled = true;
          stopBtn.style.display = 'none';
          document.getElementById('paleRow').style.display = 'none';
        } else if (unlockContext === "settings") {
          openSettingsModal();
        }
        unlockContext = null;
      } else {
        failCount++;
        passwordInput.value = '';
        confirmPassword.disabled = true;
        if (failCount >= 3){
          popupMsg.textContent = `Trop d'essais. Verrouillé ${LOCKOUT_SECONDS}s.`;
          lockoutUntil = Date.now() + LOCKOUT_SECONDS * 1000;
          setTimeout(()=>{ popupOverlay.style.display = 'none'; }, 2500);
          setTimeout(()=>{ failCount = 0; }, LOCKOUT_SECONDS * 1000);
        } else {
          popupMsg.textContent = `Incorrect. Essais restants: ${3 - failCount}`;
        }
      }
    });

    /* ====== Settings button (requires password) ====== */
    settingsBtn.addEventListener('click', () => {
      if (settingsOverlay.style.display === 'flex') {
        settingsOverlay.style.display = 'none';
        return;
      }
      if (Date.now() < lockoutUntil){
        const remaining = Math.ceil((lockoutUntil - Date.now())/1000);
        alert(`Verrouillé. Attendez ${remaining}s.`);
        return;
      }
      unlockContext = "settings";
      popupOverlay.style.display = 'flex';
      passwordInput.value = '';
      confirmPassword.disabled = true;
      popupMsg.textContent = '';
      passwordInput.focus();
    });

    function openSettingsModal(){
      populateSettingsFields();
      settingsOverlay.style.display = 'flex';
      // ensure inputs for "current time" start in muted 00:00:00 state
      setCurrentTimeInputsToMuted();
      setTimeout(()=>document.activeElement.blur(), 0);
    }

    function populateSettingsFields(){
      typeInput.value = config.type || '';
      paleInput.value = config.pale || '';
      mouleInput.value = config.moule || '';
      const parts = secondsToHMS(config.targetSec || 0);
      targetHours.value = parts.h.toString();
      targetMinutes.value = String(parts.m).padStart(2,'0');
      targetSeconds.value = String(parts.s).padStart(2,'0');

      // For current time inputs we DO NOT show the real elapsed — per your request they start grayed 00:00:00
      currentHours.value = '00';
      currentMinutes.value = '00';
      currentSeconds.value = '00';

      // flags to detect which current boxes the user edited
      currentHours.dataset.modified = '0';
      currentMinutes.dataset.modified = '0';
      currentSeconds.dataset.modified = '0';

      document.getElementById('paleRow').style.display = running ? 'flex' : 'none';
    }

    function setCurrentTimeInputsToMuted() {
      currentHours.classList.add('muted');
      currentMinutes.classList.add('muted');
      currentSeconds.classList.add('muted');
      // ensure placeholders shown as 00 and not pre-filled from elapsed
      currentHours.value = '00';
      currentMinutes.value = '00';
      currentSeconds.value = '00';
      // leave dataset.modified at '0' (unmodified)
    }

    function unmuteInput(el) {
      el.classList.remove('muted');
    }

    // If the user focuses or types into any current-time input -> mark as modified and un-muted
    [currentHours, currentMinutes, currentSeconds].forEach((el) => {
      el.addEventListener('focus', () => {
        if (el.dataset.modified !== '1') {
          el.dataset.modified = '1';
          // if the user focused but left it blank, set to 0 so parse works
          if (!el.value) el.value = '0';
          unmuteInput(el);
        }
      });
      el.addEventListener('input', () => {
        // whenever they type, mark modified and unmute
        el.dataset.modified = '1';
        unmuteInput(el);
      });
      // allow clicking the number to unmute (for accessibility)
      el.addEventListener('click', () => {
        if (el.dataset.modified !== '1') {
          el.dataset.modified = '1';
          unmuteInput(el);
        }
      });
    });

    closeSettings.addEventListener('click', ()=> { settingsOverlay.style.display = 'none'; });

    saveSettings.addEventListener('click', ()=> {
      // read and parse settings fields
      const newType  = (typeInput.value || '').trim() || '47.3';
      const newPale  = (paleInput.value || '').trim().replace(/\D/g,'');
      const newMoule = (mouleInput.value || '').trim();
      const newTargetSec = parseHMSParts(targetHours.value, targetMinutes.value, targetSeconds.value);
	


      // apply
      config.type = newType;
      config.pale = newPale;
      config.moule = newMoule;
      config.targetSec = newTargetSec;

      saveConfigToStorage();
      ensureStatsEntryFor(newType);
      saveStatsToStorage();

      // Determine whether to change current elapsed based only on modified current-time inputs.
      // For any part NOT modified, we use the *current elapsed value* (if running) as that part.
      let currentElapsed = 0;
      if (running && startTimestamp) {
        currentElapsed = Math.floor((Date.now() - startTimestamp)/1000);
      }
      const curParts = secondsToHMS(currentElapsed);

      const useHours = currentHours.dataset.modified === '1';
      const useMinutes = currentMinutes.dataset.modified === '1';
      const useSeconds = currentSeconds.dataset.modified === '1';

      // If any of the current-time boxes were modified, build new current seconds combining
      // modified boxes (user-specified) and unmodified boxes (from curParts).
      let newCurrentSec = null;
      if (useHours || useMinutes || useSeconds) {
        const h = useHours ? (parseInt(currentHours.value||'0',10)||0) : curParts.h;
        const m = useMinutes ? (parseInt(currentMinutes.value||'0',10)||0) : curParts.m;
        const s = useSeconds ? (parseInt(currentSeconds.value||'0',10)||0) : curParts.s;
        newCurrentSec = Math.max(0, h*3600 + Math.min(59,m)*60 + Math.min(59,s));
      }

// If newCurrentSec is defined and > 0
if (newCurrentSec !== null && newCurrentSec > 0) {
  if (running) {
    // Timer is already running: adjust startTimestamp so elapsed matches
    if (tickTimeoutId) {
      clearTimeout(tickTimeoutId);
      tickTimeoutId = null;
    }
    running = true;
    alarmPlayed = false;
    startTimestamp = Date.now() - (newCurrentSec * 1000);
    scheduleTick();
  } else {
    // Timer is not running: just display that time, no ticking yet
    timerEl.textContent = formatHMS(newCurrentSec);
    timerEl.classList.remove('red');
  }
} else {
  // If nothing set, and not running, reset display
  if (!running) {
    timerEl.textContent = '00:00:00';
    timerEl.classList.remove('red');
  }
}

      updateStatsUI();
      settingsOverlay.style.display = 'none';
    });

    // Live inline pale editing while running
    paleInlineInput.addEventListener('input', () => {
      const cleaned = paleInlineInput.value.replace(/\D/g, '');
      paleInlineInput.value = cleaned;
      config.pale = cleaned;
      saveConfigToStorage();
      paleStat.setAttribute('data-value', config.pale || '');
    });

    /* ====== Secret CLR reset (C + L + R) - clears active type only & persists ====== */
    const pressed = new Set();
    function resetCurrentTypeStats(){
      const t = config.type;
      stats[t] = { runs: [], count: 0 };
      saveStatsToStorage();
      updateStatsUI();
      console.log('Stats reset for', t);
    }
    document.addEventListener('keydown', (e) => {
      const k = (e.key || '').toLowerCase();
      pressed.add(k);
      if (pressed.has('c') && pressed.has('l') && pressed.has('r')) {
        e.preventDefault();
        bladeInput.value = bladeInput.value.replace(/\D/g,'');
        resetCurrentTypeStats();
        pressed.clear();
      }
    });
    document.addEventListener('keyup', (e) => { pressed.delete((e.key||'').toLowerCase()); });

    /* ====== Fullscreen support + F-key; swap icons to provided PNGs ====== */
    fullscreenBtn.addEventListener('click', () => { toggleFullScreen(); });
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'f') {
        e.preventDefault();
        toggleFullScreen();
      }
    });
    function toggleFullScreen(){
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(()=>{});
      } else {
        document.exitFullscreen().catch(()=>{});
      }
    }
    document.addEventListener('fullscreenchange', () => {
      if (document.fullscreenElement) {
        fullscreenIcon.src = 'images/exitfullscreen.png';
        fullscreenIcon.alt = 'Quitter plein écran';
      } else {
        fullscreenIcon.src = 'images/fullscreen.png';
        fullscreenIcon.alt = 'Plein écran';
      }
    });

    /* ====== Initialization ====== */
    function init(){
      // normalize & persist config
      config.type = config.type || DEFAULT_CONFIG.type;
      config.moule = config.moule || DEFAULT_CONFIG.moule;
      config.pale = config.pale || DEFAULT_CONFIG.pale;
      config.targetSec = (typeof config.targetSec === 'number') ? config.targetSec : DEFAULT_CONFIG.targetSec;
      saveConfigToStorage();

      // ensure stats bucket exists
      ensureStatsEntryFor(config.type);
      saveStatsToStorage();

      updateStatsUI();
      settingsOverlay.style.display = 'none';
      popupOverlay.style.display = 'none';
      showPaleInline(false);
      document.getElementById('paleRow').style.display = 'none';

      // Ensure current-time inputs are in muted state initially
      currentHours.value = '00';
      currentMinutes.value = '00';
      currentSeconds.value = '00';
      currentHours.dataset.modified = '0';
      currentMinutes.dataset.modified = '0';
      currentSeconds.dataset.modified = '0';
      setCurrentTimeInputsToMuted();
    }
    init();

    // cleanup ticks on unload
    window.addEventListener('beforeunload', ()=> { if (tickTimeoutId) clearTimeout(tickTimeoutId); });
  </script>
</body>
</html>
